# 第一章 OS
## 中断
1、中断分类：异常：陷入=trap=访管（应用程序故意引起）、故障（错误条件引起，例如缺页故障）、终止（致命错误，无法修复）
			中断：时钟中断、I/O中断
2、中断根据中断信号类型，查询中断向量表，找到中断处理程序指针，找到中断处理程序。
3、中断作用：让OS内核强行夺回CPU控制权、让CPU从用户态变为内核态
## 系统调用
1、由OS内核对共享资源进行统一的管理，并向上提供“系统调用”，用户使用共享资源只能通过系统调用向内核发出请求，内核对各个请求进行协调处理。
2、系统调用过程：传递系统调用参数->执行陷入指令（用户态）->执行相应的内核请求程序处理系统调用（核心态）->返回应用程序
## OS体系结构
### 大内核结构
1、内核1：（1）时钟管理 （2）中断处理 （3）原语：是一种特殊的程序、处于OS最底层，最接近硬件、运行具有原子性、运行时间短调用频繁
2、内核2：对系统资源进行管理的功能：进程管理、存储器管理、设备管理
3、非内核功能：GUI
4、优缺点：高性能、内核代码庞大难以维护
5、不同模块需要有消息传递来进行不同模块通信
### 微内核结构
1、内核：（1）时钟管理 （2）中断处理 （3）原语：是一种特殊的程序、处于OS最底层，最接近硬件、运行具有原子性、运行时间短调用频繁
2、非内核：对系统资源进行管理的功能：进程管理、存储器管理、设备管理
3、非内核功能：GUI
4、优缺点：内核功能少便于维护、频繁切换状态性能低

频繁的在内核态和用户态直接切换会降低系统性能，因为转变状态是有成本的

### 分层结构
最底层为硬件、最高层是用户接口
每层只能调用相邻层的接口
便于调试和维护
有时候难以定义每层边界，例如进程和内存；效率低，系统调用时间长

### 模块化
内核=主模块+可加载内核模块
逻辑清晰易于维护；支持动态加载新模块；不同模块可以直接调用接口
模块定义未必合理实用；模块相互依赖难以调试

### 外核


## OS引导
OS引导开机过程：
![[OS引导开机.png]]

## 虚拟机
### 多系统
直接运行在硬件上
将cpu划分为时间片或者其他的分配给每个OS
性能更好
可以支持更多的虚拟机
### 宿主OS
运行在宿主OS上，宿主为其分配物理资源
性能更差
比较方便迁移
![[两类虚拟机区别.png]]

# 第二章 进程
## 进程
### 进程概念、组成
1、程序是静态的；进程是动态的，是程序的一次执行过程，同一个程序多次执行对应多个进程
2、组成：
	（1）PCB：信息均被保存在PCB中（进程控制块）；进程描述信息PID（进程ID）、资源分配清单、进程控制和管理信息、处理机相关信息（例如PSW和PC）；给OS使用
	（2）程序段&数据段：程序的代码、运行中产生数据；给进程自己用
进程是进程实体的运行过程，是系统进行**资源分配**和**调度**的独立单位

### 进程状态、转换、组织
#### 状态
1、创建态：分配资源、初始化PCB
2、就绪态：已具备运行条件，由于无空闲CPU，暂时无法运行
3、运行态：进程在CPU上运行，CPU正在执行进程对应的程序
4、阻塞态：进程运行时，请求等待某个事件的发生，在这个事件发生前，进程无法继续执行
5、终止态：执行exit系统调用，OS回收内存、PCB等资源
#### 转换
![[五状态模型.png]]
#### 组织
##### 链式方式
具有==相同状态进程的PCB==分别通过PCB中的链接字链接成一个队列，后面的数字代表下一个PCB
![[PCB组织方式--链式链接.png| 300]]
执行指针：对于单CPU计算机，同一时间只有一个进程处于运行态
就绪队列：通常会把优先级高的放在队头
阻塞队列：很多OS会根据阻塞原因将其分为多个阻塞队列
##### 索引方式
根据进程状态不同，建立几张索引表，在需要特定PCB时，直接查询索引表来查找PCB表
##### 线性方式
系统中==所有PCB==都组织在一张线性表中，表的首地址存放在内存专用区，会导致每次查询都扫描整个表
### 进程控制
#### 概念
实现进程控制使用原语，不可被中断；原语处于内核中
原语的原子性由==开中断==和==关中断==两个特权指令实现原子性
#### 进程控制
##### 进程创建
创建原语：申请PCB、分配资源、初始化PCB、将PCB插入就绪队列
##### 进程终止
撤消原语：从PCB集合中找到该PCB、若正在运行则剥夺CPU，将CPU分配给其他进程、终止所有子进程、将资源还给父进程或OS、删除PCB
##### 进程阻塞
阻塞原语：找到要阻塞的进程对应的PCB、保护进程运行现场，将PCB状态设为阻塞态、将PCB插入相应事件的等待队列
进程由什么事件阻塞，就由什么事件唤醒
##### 进程唤醒
唤醒原语：在事件等待队列中找到PCB、将PCB从等待队列中移除，设置进程为就绪态、将PCB插入就绪队列，等待被调度
##### 进程切换
切换原语：将运行环境存入PCB、PCB移入相应队列、选择执行另一个进程，更新PCB、根据PCB恢复新进程所需运行环境
### 进程通信
#### 共享存储
进程p申请共享存储区，当要给进程q传输数据时候，将数据写入共享存储区，进程q就可以读取了。
Linux实现共享内存
int shm_open(); //通过该系统调用，申请一片共享内存
void * mmap();  //通过该系统调用，将共享内存映射到进程自己的地址空间
**通过”增加页表项/段表项“可将同一片共享内存映射到各个进程的地址空间**
**为了避免出错，各个进程对共享空间的==访问==应该是==互斥==的，由通信进程自己负责实现**
**各个进程可以使用内核提供的同步互斥工具；如P、V操作**


##### 基于数据结构的共享
比如共享空间里面只能放一个长度为10的数组；速度慢限制多，是低级通信方式。
##### 基于存储区的共享
OS在内存中划出一块共享存储区，数据形式、存放位置由通信进程控制，而非OS；速度快，是高级通信方式。
#### 消息传递
数据交换以格式化的消息为单位，进程通过OS提供的**发送消息/接收消息**两个原语进行数据交换。
消息包括了消息头，消息体；消息头包括：发送进程ID、接收进程ID、消息长度等格式化信息
##### 直接通信方式
进程的PCB中包括了进程的消息队列，其他进程要向目标进程发送消息，会将消息复制到目标进程的进程消息队列，然后接受信息的进程通过发送者名字，在消息队列中查找目标信息，然后将其复制到自己的进程内存中。
##### 间接通信方式
进程p需要进行传输信息，会向内存申请一个信箱，然后将消息发送到信箱A，然后进程q从信箱A中接收信息。
可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息。
#### 管道通信
管道：是一个特殊的共享文件，在内存中开辟一个==大小固定==的内存缓冲区，并且只能单向传递数据，数据为先进先出（FIFO）。
1、只能采用半双工通信，某一时间段内只能实现单向传输。
2、如果管道写满，写进程阻塞，直到读进程将数据取走；如果管道读空，读进程阻塞，直到写进程写入数据。
3、管道中数据一旦被读出，就彻底消失，当多个进程读一个管道时候，可能会引起错乱。
解决方案：1）一个管道允许多个写进程，一个读进程。（官方答案）
		  2）允许有多个写进程和多个读进程，OS会让各个读进程轮流读数据。（Linux方案）
进程通过系统调用的方式申请一个管道， 
### 线程
同一个进程分为不同线程，可以在一个进程中执行不同的功能
同一个进程可以包括多个不同的线程
线程是一个最基本的CPU执行单元，是程序执行流的最小单位
引入线程后，不仅是进程之间可以并发，进程内各线程也可以并发，使得一个进程可以并发处理各种任务
系统资源是分配给进程，并发的不同线程不需要切换线程，系统开销变小

线程属性：
1、线程是处理机调度的基本单位
2、多CPU计算机中，各个线程可占用不同的CPU
3、每个线程都有一个线程ID、线程控制块（TCB）
4、线程也有就绪、阻塞、运行三种基本状态
5、同一进程的不同线程可以共享进程的资源
6、由于共享内存地址，同一进程中线程通信甚至不需要系统干预

### 线程的实现方式
#### 用户级线程
```c
int main(){
	int i = 0;
	while (true){
		if (i == 0) {处理视频聊天的代码；}
		if (i == 1) {处理文字聊天的代码；}
		if (i == 2) {处理文件传输的代码；}
		i = (i + 1) % 3;  //i的值为0，1，2，0，1，2···
	}
}
```
上述三段代码可以看作三个”线程“，while循环就是最简陋的”线程库“，线程库完成了对线程的管理工作（如调度）

1、线程管理：应用程序通过线程库来管理
2、线程切换不需要CPU转换状态
3、OS不能意识到线程存在
4、优点：在用户态下即可完成，不需要切换到核心态；线程管理系统开销小，效率高
    缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高；多个线程无法在不同CPU上运行
#### 内核级线程
1、线程管理：有OS管理
2、线程切换需要CPU转换状态
3、优点：多线程可以在多核处理机并发执行；线程被阻塞后别的线程可以继续执行
	缺点：一个用户进程会占用多个内核级线程，线程切换由OS内核完成，需要切换到核心态，因此管理成本高，开销大
#### 多线程模型
一对一模型：一个用户级线程映射到一个内核级线程；每个用户进程有与用户级线程同数量的内核级线程。
多对一模型：多个用户级线程映射到一个内核级线程；且一个进程只被分配到一个内核级线程。 
多对多模型：n个用户级线程映射到m个内核级线程（n>=m）；每个用户进程对应m个内核级线程。
![[线程.png]]
#### 线程状态与转换
就绪态、运行态、阻塞态
![[线程状态转换.png]]
#### 线程的组织与控制
TCB：线程标识符（TID）；程序计数器PC、其他寄存器、堆栈指针、线程运行状态、优先级（线程调度、资源分配的参考）
将多个TCB组织成一张线程表。
![[TCB.png]]
## 调度

### 调度概念和层次
#### 作业调度（高级调度）
按一定原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只==调入一次、调出一次==。调入时创建PCB，调出时撤销PCB。
无->创建态->就绪态
#### 进程调度/处理机调度（低级调度）
从进程就绪队列中按某种策略选取一个进程，将处理机分配给它。
最基本的一种调度，频率很高
挂起态->就绪态/阻塞挂起->阻塞态
#### 内存调度（中级调度）
内存不够时，将某些进程的数据调出至外存，等内存空闲或者进程需要运行时再重写调入内存
暂时掉到外存等待的进程状态为挂起状态，被挂起进程的PCB会被组织成挂起队列。
频率比高级调度略高
就绪态->运行态
#### 进程挂起态和七状态模型
![[七状态模型.png]]
### 进程调度时机、切换与过程、方式
#### 时机
需要进行调度与切换：
1、主动放弃处理机：进程正常终止、运行过程中发生异常、进程主动请求阻塞（如等待I/O）
2、被动放弃处理机：分配的时间片用完、有更紧急的事情需要处理（如I/O中断）、有优先级更高的进程进入就绪队列

不能进行调度和切换：
1、处理中断
2、OS内核程序临界区
3、原子操作过程中

> 进程在OS内核程序临界区不能进行调度与切换-----正确
> 进程处于临界区时不能进行处理机调度-----错误

临界区：访问临界资源的代码
内核程序临界区：一般是用来访问某种内核数据结构，比如进程的就绪队列
#### 方式
非剥夺调度方式：只允许进程主动放弃处理机，若有优先级更高的，一直等待直到高进程终止或进入阻塞态；系统开销小，无法及时处理紧急任务
剥夺调度方式：若有更重要或更紧迫的进程要使用处理机，立即暂停当前正在执行的进程，将处理机分配给更紧迫的进程；可优先处理更紧急进程，可实现让个进程按时间片轮流执行的功能，适用于分时OS和实时OS
#### 切换与过程
##### 狭义进程调度
从就绪队列里面选一个要运行的进程，这个进程可以是刚刚被暂停执行的进程，也可也是另一个进程，若是另一个进程，则需要进行进程切换
##### 广义进程调度
包含了选择进程和进程切换两个步骤

### 调度器、闲逛进程
#### 调度器/调度程序（scheduler）
非抢占式调度策略：只有运行进程阻塞或退出才触发调度程序
抢占式调度策略：每个时钟中断或k个时钟中断会触发调度程序工作
#### 闲逛进程
当没有其他就绪进程时，运行闲逛进程
优先级最低、可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）、能耗低
### 调度算法评价标准
#### CPU利用率
CPU利用率 = 忙碌时间 / 总时间
#### 系统吞吐量
单位时间内完成作业数量
系统吞吐量 = 总共完成多少道作业 / 总共花了多少时间
#### 周转时间
从作业被提交给系统开始，到作业完成的这段时间间隔
作业周转时间 = 作业完成时间 - 作业提交时间
平均周转时间 = 各作业周转时间之和 / 作业数
带权周转时间 = 作业周转时间 / 作业时间运行时间
平均带权周转时间 = 各作业带权周转时间之和 / 作业数
#### 等待时间
等待时间 = 周转时间 - 运行时间 - I/O操作时间
进程/作业处于等待处理机状态时间之和
等待I/O完成的期间其实进程也在被服务，不计入等待时间
等待时间还要计算作业在外存后备队列中等待的时间
#### 响应时间
用户从提出请求到首次响应的时间
### 调度算法
#### 先来先服务（FCFS）
可用于作业/进程

| 进程 | 到达时间 | 运行时间 |
| ---- | ---- | ---- |
| P1 | 0 | 7 |
| P2 | 2 | 4 |
| P3 | 4 | 1 |
| P4 | 5 | 4 |
调度顺序：P1->P2->P3->P4
周转时间：P1=7-0=7 P2=11-2=9 P3=12-4=8 P4=16-5=11
带权周转时间：P1=1 P2=2.25 P3=8 P4=2.75
等待时间：P1=0 P2=5 P3=7 P4=7（若有I/O操作，周转时间-运行时间-I/O操作时间）
平均周转时间：8.75
平均带权周转时间：3.5
平均等待时间：4.75

不会导致==饥饿==（某进程/作业长期得不到服务）
对长作业有利，对短作业不利
#### 短作业/进程优先（SJF/SPF）
可用于作业/进程
追求更少平均等待时间、平均周转时间、平均带权周转时间
默认非抢占式算法

| 进程 | 到达时间 | 运行时间 |
| --- | --- | --- |
| P1 | 0 | 7 |
| P2 | 2 | 4 |
| P3 | 4 | 1 |
| P4 | 5 | 4 |
调度选择当前已到达，且运行时间最短的作业
调度顺序：P1->P3->P2->P4
平均周转时间：8
平均带权周转时间：2.56
平均等待时间：4

最短剩余时间优先算法
![[最短剩余时间优先算法.png]]
使用抢占式短作业调度优先算法
平均周转时间：7
平均带权周转时：1.5
平均等待时间：3

在所有进程同时可运行/在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少。
短作业优先对于运行时间是用户提供，不一定真是，所以不一定真正短作业优先
有可能导致饥饿，由于短作业源源不断的来，会导致长作业长期得不到服务

#### 高响应比优先（HRRN）
可用于作业/进程
每次调度时先计算各个作业响应比，选择响应比最高的作业为其服务
响应比 = （等待时间+要求服务时间）/ 要求服务时间
非抢占式算法，当前作业主动放弃处理机时，才需要调度，需要计算响应比

| 进程 | 到达时间 | 运行时间 |
| ---- | ---- | ---- |
| P1 | 0 | 7 |
| P2 | 2 | 4 |
| P3 | 4 | 1 |
| P4 | 5 | 4 |
0时刻：P1上处理机
7时刻：P2（响应比 = （5+4）/4 = 2.25）、P3（响应比 = （3+1）/1 = 4）、P4（响应比 = （2+4）/4 = 1.5），P3上处理机
8时刻：P2（2.5）、P4（1.75）；P2上处理机
12时刻：P4上处理机

综合考虑等待时间和运行时间，结合了SJF和FCFS优点
不会导致饥饿


![[三种调度算法比较1.png]]
#### 时间片轮转调度算法（RR）
可用于进程
OS按照进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，重新放入就绪队列队尾进行排队。

常用于分时操作系统，注重响应时间，不计算周转时间
当某进程已经运行结束，但是时间片为用完，则同样发生调度
抢占式算法，由时钟装置发出时钟中断来通知CPU

| 进程 | 到达时间 | 运行时间 |
| ---- | ---- | ---- |
| P1 | 0 | 5 |
| P2 | 2 | 4 |
| P3 | 4 | 1 |
| P4 | 5 | 6 |

假设时间片为2
调度顺序：P1->P2->P1->P3->P2->P4->P1->P4
假设时间片大小为5
调度顺序：P1->P2->P3->P4

假设时间片太大，RR会退化为FCFS，增大进程响应时间，因此时间片不能太大
假设时间片太小，系统会花费大量时间切换进程
一般时间片大小使得切换进程时间小于1%

公平，响应快，适用于分时OS；由于高频率切换进程，有一定开销；不区分任务的紧急程度
不会导致饥饿

#### 优先级调度算法
可用于作业/进程
每个作业/进程有各自优先级
抢占式和非抢占式均有

就绪队列未必只有一个，可以按照不同优先级来组织。可以把优先级高的进程排在更靠近队头的位置
静态优先级：创建进程时确定，之后一直不变
动态优先级：创建进程时有一个初始值，之后根据情况动态调整优先级

设置优先级：
系统进程 高于 用户进程
前台进程 高于 后台进程
操作系统更偏好I/O进程，而非计算型进程（I/O设备可以和CPU并行工作，优先I/O可以让设备尽早投入工作）

采用动态优先级调整时机：
某进程在就绪队列中等待很久，可以适当提高优先级（例如HRRN，等待时间变长则响应比增大）
某进程占用处理机运行了很久，可以适当降低优先级
某进程频繁进行I/O操作，可以适当提升优先级

若源源不断的有高优先级进程到来，可能会导致饥饿
#### 多级反馈队列调度算法
用于进程调度

| 进程 | 到达时间 | 运行时间 |
| ---- | ---- | ---- |
| P1 | 0 | 8 |
| P2 | 1 | 4 |
| P3 | 5 | 1 |

设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；
==新进程==到达时，==先进入1级队列==，按照==FCFS==排队等待分配时间片；
若时间片进程还==未结束==，则进程进入==下一级==队列**队尾**；
若此时有更高优先级的进程到达，处理机被抢占，本进程放回原队列；
若此时已经在==最下级队列==，则==重新放回==最下级队列队;
只有==第k级队列为空==，才会为==k+1级==队头的进程分配时间片；
==被抢占处理机==的进程重新放回==原队列队首==。

调度顺序：P1(1)->P2(1)->P1(2)->P2(2)->P3(1)->P2(2)->P1(4)->P1(1)

结合了FCFS、RR、SPF的优点；可灵活调整对各类进程的偏好（例如：因I/O而阻塞的进程重新放回原队列，可以保持高优先级）
若源源不断的有短进程传入，并且在第一级的时间片就完成了，有可能会导致下层进程饥饿
![[三种调度算法比较2.png]]
#### 多级队列调度算法
![[多级队列调度算法.png]]

## 进程同步、互斥
### 进程同步、进程互斥
进程具有异步性，异步性是指各并发执行的进程以各自独立、不可预知的速度向前推进。
同步又称直接制约关系，它是指为了完成某种任务而进阿里的两个或多个进程，因为需要在某些位置上协调他们的工作次序而产生的制约关系。
互斥，某个进程访问临界资源时候，其他想访问的进程必须等待，直到该进程释放资源。
```c
do {
	entry section;      //进入区，用于检查是否可进入临界区，若可以则上锁
	critical section;   //临界区，访问临界资源的代码
	exit section;       //退出区，解锁
	remainder section;  //剩余区，做其他处理
} while(true)
```
空闲让进：无进程处于临界区，请求的进程可进入
忙则等待：有进程进入临界区，其他请求的进程则等待
有限等待：对于要求访问临界资源的进程，需要保证在有限时间内进入临界区，避免死等（进程在有限时间内无法进入临界区，而一直尝试进入，陷入一种无结果的等待状态），受惠的是自己
让权等待：当进程自己不能进入临界区时，应当立即释放处理机，避免进入忙等（一个进程处于临界区内，其他进程都必须进入代码连续循环，陷入忙等，连续测试某个变量的某个值，直到出现），受惠的是别人
### 进程互斥软件实现方法
#### 按需访问
```Pascal
VAR busy: boolean := false;
Program P0:
Begin
	repeat
		while (busy);
		busy := true;
		critical section;
		busy := false;
		remainder section;
	until false
End
Program P1:
Begin
	repeat
		while(busy);
		busy := true;
		critical section;
		busy := false;
		remainder section;
	until false
End
```

资源空闲标志：busy
若程序想进入临界区，检查busy；若busy为false，则将busy设为true，并进入临界区，完成临界区操作之后再将busy设置为false，让其他程序可进入临界区。
不高效：它导致在等待进入临界区时候的CPU周期浪费（忙等待）
违背的原则：
忙则等待：此方法会使进程忙碌时进行等待，等待资源时会不断查询busy是否变为false，而不是挂起，导致CPU时间浪费
让权等待：不一定遵循让权等待原则，因为等待资源的进程可能不会让出CPU而是持续检查资源状态
有限等待：没有机制来确保每个等待资源的进程可以在合理时间内访问到该资源


#### 轮询（单标志法）
```Pascal
VAR turn: integer := 1;
Program P1:
Begin
	repeat
		while(turn = 2);
		critical section;
		turn := 2;
		remainder section;
	until false
End
Program P2:
Begin
	repeat
		while(turn = 1);
		critical section;
		turn := 1;
		remainder section;
	until false
End
```

轮转标志：turn
turn = 1 ：轮到P1
turn = 2 ：轮到P2
违背的原则：
严格限制资源访问顺序：轮询是以随机或者非预定的方式访问资源
让权等待：轮询模式下，进程可能持续检查资源而非在无法获取CPU时让出CPU；不可访问临界区的进程在进入区一直检查，空转等待
有限等待：进程可能需要不确定的时间才能成功访问资源

==王道==
主要违背空闲让进：P0当前从临界区退出之后，P0 = 1；但是P1一直不访问临界区，则P0一直为1，并且临界区空闲，不让P0访问

#### 访前先看（双标志后检查法）
```Pascal
VAR pturn, qturn : boolean := false, false;
Program P:
Begin
	repeat
		pturn := true;  //p想访问
		while(qturn);   //q想访问
		critical section;
		pturn := false;
		remainder section;
	until false
End
Program Q:
Begin
	repeat
		qturn := true;
		while(pturn);
		critical section;
		qturn := false;
		remainder section;
	until false
End
```

愿望标志：pturn，qturn
pturn = true ：P想访问
qturn = ture ：Q想访问

当pturn := true时，代表进程P想要访问临界区，while(qturn)这行代码是的P在Q想要访问临界区时（即qturn == true）等待，当Q不想访问临界区时，P才能进入临界区。因为while(qturn)会在qturn == true时持续循环，阻止P进入critical section。

空闲让进：即使资源空闲，进程也有可能由于其他条件（例如检查结果qturn == true，即二者都想访问临界区）而不让进入
让权等待：进程在检查资源状态后持续占用CPU，等待资源变为可用，而不是在资源不可以时候让出CPU
有限等待：这种方法依赖于进程主动检查资源，而没有机制确保公平或者有限时间内访问

#### Peterson算法
```Pascal
//函数：
#define FALSE 0 
#define TRUE 1 
#define N 2 // 进程的个数 
int turn; //表达谦让 表示优先让哪个进程进入临界区
int interested[N]; //表达进入临界区意愿 初始值均为FALSE 
void enter_region ( int process) // process = 0 或 1 
{ 
int other; //对方
other = 1 - process; 
interested[process] = TRUE;//表达自己意愿
turn = other; //表达谦让对方
while( turn == other && interested[other] == TRUE);  //对方想用且最后自己表达谦让，则检查
} 
void leave_region ( int process) 
{ 
interested[process] = FALSE; // 本进程已离开临界区 
}
//具体实现：
Program P1: 
Begin
	repeat 
	enter_region(0); 
	critical section ; 
	leave_region(0); 
	remainder section ; 
	until false 
End 
Program P2: 
Begin 
	repeat 
	enter_region(1); 
	critical section ; 
	leave_region(1); 
	remainder section ; 
	until false 
End
```
无法实现让权等待，若当前进程无法进入临界区，就会卡在while循环，仍然占用CPU，无法让出。
### 进程互斥的硬件实现方法
#### 中断屏蔽
访问临界区前，执行关中断、访问完执行开中断
优点：简单高效
缺点：不适用多处理器（切换进程之后会导致访问同一个进程）；只适用于内核进程（这两个指令只能运行在内核态）
#### TestAndSet/TestAndSetLock指令
TS指令/TSL指令
由硬件实现，执行过程中不允许中断

c语言描述的逻辑：
```c
bool TestAndSet(bool *lock){
	bool old;
	old = *lock; //old存放lock原来的值
	*lock = true; //无论之前是否已经加锁，都将其设置为true
	return old;  //返回lock原来的值
}

whlie(TestAndSet(&lock)){};  //上锁并检查
临界区代码段;
lock = false;  //解锁
剩余区代码段;
```

优点：实现简单；适用于多处理机环境
缺点：不满足让权等待，当lock时，另一个进程一直占用CPU并循环执行TSL指令，从而导致忙等
#### Swap/XCHG指令
由硬件实现，执行过程中不允许中断
Pascal描述的逻辑：
```Pascal
// 交换锁lock和key的值 
function SWAP(lock, key ) { 
var tmp : boolean := lock ; 
lock := key ; 
key := tmp ; 
}

function enter_region( var lock : boolean ) 
Var key:boolean ; //局部变量 
Begin 
	key := true; 
	while(key) SWAP(lock,key); 
end 

function leave_region( var lock : boolean ) 
Begin 
	lock := false; 
end

VAR lock :boolean := false ; 
Program P1: 
Begin 
	repeat 
		enter_region(lock ); 
		critical section ; 
		leave_region(lock); 
		remainder section ; 
	until false 
End 
Program P2: 
Begin 
	repeat 
		enter_region(lock); 
		critical section ; 
		leave_region(lock); 
		remainder section ; 
	until false 
End
```
c语言描述的逻辑：
```c
//swap指令的作用是交换两个变量值
swap(bool *a, bool *b){
	bool temp;
	temp = *a;
	*a = *b;
	*b = temp;
}

bool old = true;
while (old == true)
	swap(&lock, &old)
临界区代码;
lock = false;
剩余区代码;
```
循环检测old是否为true，即以前是否上锁，若上锁则循环；若不上锁则进入临界区
优点：实现简单；适用于多处理机环境
缺点：不满足让权等待，当lock时，另一个进程一直占用CPU并循环执行TSL指令，从而导致忙等
### 互斥锁
```c
acquire(){
	while(!available); //忙等
	available = false; //获得锁
}

release(){
	available = true;  //释放锁
}

```
acquire()和release()必须是原子操作
缺点：忙等
优点：等待期间不用切换进程，多处理器系统中，若上锁时间短，则等待代价很低；可以等到其他核的进程释放资源后，瞬间获得资源
忙等只有在时间片用完才下处理机，违反让权等待；
### 信号量机制
定义：用户进程可以通过OS提供的==一对原语==来对信号量进行操作，从而方便实现进程同步、进程互斥
该==一对原语==为：**wait(S)原语**和**signal(S)原语**，信号量S是传入的参数
wait、signal原语通常简称为P、V操作；表示为P(S)、V(S)
#### 整型信号量
用一个整数型的变量作为信号量，来表示系统中某种资源的数量
除初始化外，S只能由wait/signal访问
```Pascal
VAR S:integer := 1 ;              //初始化信号量S，表示当前系统中可用的资源数
function Wait ( var S: integer )  //wait原语，相当于进入区
Begin 
	while ( S <= 0 ) do no_op();  //如果资源不够，就一直循环等待
	S := S-1;                     //如果资源够，则占用一个资源
end
function Signal( var S : integer )//signal原语，相当于退出区
Begin 
	S := S+1;                     //使用完资源后，在退出区释放资源
end

VAR S:integer := 1 ; 
Program P1: 
Begin 
	repeat 
		wait(S);   //进入区，申请资源
		critical section ; 
		signal(S); //退出区，释放资源
		remainder section ; 
	until false 
End 
Program P2: 
Begin 
	repeat 
		wait(S); 
		critical section ; 
		signal(S); 
		remainder section ; 
	until false 
End
```
如果资源不够，会一直循环等待，不满足==让权等待==，会发生忙等
#### 记录型信号量
除初始化外，S只能由wait/signal访问
```Pascal
type semaphore = record 
	value: integer ; // 资源数量 
	L: list of process ; // 阻塞进程队列 
end 
function wait ( var S ：Semaphore ) 
Begin 
	S.value := S.value-1; 
	if ( S.value < 0 ) then block (S.L);   //使进程变为阻塞态并挂到阻塞队列L中
end 
function signal(var S ：Semaphore ) 
Begin 
	S.value := S.value+1; 
	if ( S.value <= 0 ) then wakeup (S.L); //有别的进程等待资源，就从队列中唤醒一个进程
end

VAR S:semaphore := 1 ; 
Program P1: 
Begin 
	repeat 
		wait(S);   //进入区，申请资源
		critical section ; 
		signal(S); //退出区，释放资源
		remainder section ; 
	until false 
End 
Program P2: 
Begin 
	repeat 
		wait(S); 
		critical section ; 
		signal(S); 
		remainder section ; 
	until false 
End
```

S.value>=0: 资源数量； 
S.value<0 : |S.value|为阻塞进程的数量；

当资源用完之后，再来的进程会挂到阻塞队列中，value变为-1、-2、-3；当有资源被释放时，则从阻塞队列中唤醒一个进程进行分配资源。

该机制遵循了让权等待，不会忙等，当资源分配完了之后进程会主动进行自我阻塞，放弃CPU
### 信号量实现同步、互斥、前驱关系
#### 互斥
1、划定临界区
2、==设置互斥信号量mutex，初值为1==
```Pascal
VAR mutex:semaphore := 1 ; 
Program P1: 
Begin 
	repeat 
		P(mutex);   //进入区，申请资源
		critical section ; 
		V(mutex) //退出区，释放资源
		remainder section ; 
	until false 
End 
Program P2: 
Begin 
	repeat 
		P(mutex);   //进入区，申请资源
		critical section ; 
		V(mutex) //退出区，释放资源
		remainder section ; 
	until false 
End 
```
#### 同步
1、分析什么时候需要实现同步关系，即必须保证一前一后
2、==设置同步信号量S，初值为0==
例如，要求代码1、代码2在代码4前执行
```Pascal
VAR S:semaphore := 0;
Program P1:
Begin
	repeat
		代码1;
		代码2;
		V(S);
		代码3;
	until false
End

Program P1:
Begin
	repeat
		P(S);
		代码4;
		代码5;
		代码6;
	until false
End
```
1、若先执行到V(S)，则S++后S = 1，之后执行P(S)操作，由于S = 1，表示有可用资源，会执行S--，S变为0，P2进程不会执行block原语，而是继续执行代码4。
2、若先执行P(S)，由于S = 0，S--之后S = -1，表示当前没有可用资源，因此执行完P操作后会执行block原语，请求阻塞，，之后执行代码1、代码2，继续执行V(S)，S++，S变为0，由于此时有进程在阻塞队列，所以执行wakeup原语，唤醒P2进程，然后继续执行代码4。

在”前操作“之后执行V，在”后操作“之前执行P。
#### 前驱关系
![[信号量实现前驱关系结构图.png]]
1、要为每一对前驱关系各自设置一个同步信号量
2、在前操作之后对相应同步信号量执行V操作
3、在后操作之后对相应同步信号量执行P操作
![[信号量实现前驱关系代码.png]]
### 生产者-消费者问题
生产者、消费者共享一个初始为空，大小为n的缓冲区。
只有缓冲区没满，生产者才能把产品放入缓冲区，否则必须等待。（缓冲区没满->生产者生产）
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。（缓冲区没空->消费者消费）
缓冲区为临界资源，各进程互斥访问。
![[生产者-消费者前驱关系结构图.png]]步骤：
1、找到各个进程的同步、互斥关系
2、确定P、V操作顺序
3、设置信号量，确定信号量初值（互斥一般为1，同步看资源初始值）
```Pascal
VAR mutex:semaphore := 1;  //互斥信号量，访问缓冲区互斥访问
VAR empty:semaphore := n;  //同步信号量，表示空闲缓冲区数量
VAR full:semaphore := 0;   //同步信号量，表示产品数量，即非空缓冲区数量
Program producer:
Begin
	repeat
		生成产品;
		P(empty);  //消耗一个空闲缓冲区
		P(mutex);
		把产品放入缓冲区;
		V(mutex);
		V(full);   //增加一个产品
	until false
End

Program consumer:
Begin
	repeat
		P(full);   //消耗一个产品
		P(mutex);
		从缓冲区取走产品;
		V(mutex);
		V(empty);   //增加一个空闲缓冲区
		使用产品;
	until false
End
```
==实现互斥的P操作一定要在实现同步的P操作后。==
V操作不会导致进程阻塞，因此V操作可用交换。
### 多生产者-多消费者问题
![[多生产者-多消费者问题.png]]

```Pascal
VAR mutex:semaphore := 1;  //互斥访问盘子
VAR apple:semaphore := 0;  //盘中有几个苹果
VAR orange:semaphore := 0; //盘中有几个橘子
VAR plate:semaphore := 1;  //盘中可以放几个水果

Program dad:
Begin
	repeat
		准备一个苹果;
		P(plate);
		P(mutex);
		把苹果放入盘中;
		V(mutex);
		V(apple);
	until false
End

Program mom:
Begin
	repeat
		准备一个橘子;
		P(plate);
		P(mutex);
		把橘子放入盘中;
		V(mutex);
		V(orange);
	until false
End

Program daughter:
Begin
	repeat
		P(apple);
		P(mutex);
		从盘中取出苹果;
		V(mutex);
		V(plate);
		吃掉苹果;
	until false
End

Program son:
Begin
	repeat
		P(orange);
		P(mutex);
		从盘中取出橘子;
		V(mutex);
		V(plate);
		吃掉橘子;
	until false
End
```
在本例中，即使不设置互斥信号mutex也不会出现多个进程访问盘子；
因为，本例缓冲区为1，任何时刻，apple、orange、plate三个信号量中最多只有一个是1，因此最多只有一个进程P操作不会被阻塞，并成功进入临界区。
==实现互斥的P操作一定要在实现同步的P操作后。==

### 吸烟者问题
三个抽烟者进程，一个供应者进程，第一个拥有烟草、第二个有纸、第三个有胶水。供应者每次提供两种材料，拥有剩下材料的抽烟者会卷一支烟并抽掉，然后给供应者一个信号告诉完成了，要求让三个抽烟者轮流抽烟。
1、分析关系
桌子：容量为1的缓冲区，互斥访问（==即使不设置互斥变量也可以互斥访问==）
组合1：纸+胶水  组合2：烟草+胶水  组合3：烟草+纸
同步关系：（前V后P）
桌子上有组合1->第一个抽烟者取走
桌子上有组合2->第二个抽烟者取走
桌子上有组合3->第三个抽烟者取走
发出完成信号->供应者提供下一个组合
![[吸烟者问题.png]]
```Pascal
VAR offer1, offer2, offer3, finish : semaphore := 0;
VAR i : integer := 0;  //用于实现三个抽烟者轮流抽烟

Program provider:
Begin
	repeat
		if (i == 0) then
			将组合一放桌上;
			V(offer1);
		else if (i == 1) then
			将组合二放桌上;
			V(offer2);
		else if (i == 1) then
			将组合三放桌上;
			V(offer3);
		i = (i + 1) % 3;
		P(finish);
	until false
End

Program smoker1:
Begin
	repeat
		P(offer1);
		从桌上拿走组合二;
		卷烟;
		抽掉;
		V(finish);
	until false
End

Program smoker2:
Begin
	repeat
		P(offer2);
		从桌上拿走组合二;
		卷烟;
		抽掉;
		V(finish);
	until false
End

Program smoker3"
Begin
	repeat
		P(offer3);
		从桌上拿走组合二;
		卷烟;
		抽掉;
		V(finish);
	until false
End
```
### 读者写者问题
要求：
1、允许多个读者同时读文件
2、只允许一个写者写文件
3、任一写者完成写操作之前不允许其他读者或写者工作
4、写者执行写操作前，应让已有的读者和写者全部退出

分析关系：
互斥关系：写-写、写-读
```Pascal
VAR rw : semaphore := 1; //用于实现对共享文件的互斥访问
VAR count : integer := 0;//记录有几个读进程访问文件
VAR mutex : semaphore := 1;//用于保证对count变量的互斥访问
VAR w : semaphore := 1; //用于实现相对公平的先来先服务
Program write:
Begin 
	repeat
		P(w);
		P(rw);
		写文件;
		V(rw);
		V(w);
	until false
End

Program reader:
Begin 
	repeat
		P(w);
		P(mutex);
		if (count == 0) then  //是不是第一个读进程
			P(rw);
		count++;    //访问文件的读进程数+1
		V(mutex);
		V(w);
		读文件;     //只要当前读进程不为0，就不用加锁直接读取
		P(mutex);
		count--;    //访问文件的读进程数-1
		if (count == 0) then  //是不是最后一个读进程
			V(rw);
		V(mutex);
	until false
End
```
若在执行if (count == 0)时候发生了读进程的切换，就会导致两个if都满足，都执行P(rw)，导致第二个读进程阻塞
原因：对count的检查和赋值无法一气呵成，因此可以设置一个信号量保证各个进程对count的访问的互斥的。

只要有读进程还在读，写进程就会一直阻塞，可能”饿死“，这种算法中读进程的优先的。
### 哲学家进餐问题
1、关系分析：5个进程，5个哲学家与左右邻居对于其中间的筷子的访问是互斥的。
2、当哲学家持有两个筷子才能吃饭。
3、设置互斥信号量数组chopstick[5] = {1,1,1,1,1}，用于实现对五个筷子的互斥访问。对哲学家0-4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。
```Pascal
VAR chopstick[5] : semaphore := {1, 1, 1, 1, 1};
VAR mutex : semaphore := 1;   //互斥的取筷子
Program Pi:  //i号哲学家进程
Begin
	repeat
		P(mutex);
		P(chopstick[i]);         //left
		P(chopstick[(i+1)%5]);   //right
		V(mutex);
		吃饭;
		V(chopstick[i]);         //left
		V(chopstick[(i+1)%5]);   //right
	until false
End
```
当每个哲学家循环等待右边的人放下筷子，都拿起来左边的筷子，就会发生死锁。
解决：
1、最多4个哲学家同时进餐
2、要求奇数号哲学家先拿左边筷子，然后再拿右边筷子；偶数号哲学家恰恰相反。
3、==仅当一个哲学家左右筷子都可用时才允许抓起筷子==

用mutex信号量保证了拿筷子这件事是互斥的，保证了即使一个哲学家在拿筷子到一半时被阻塞，也不会有其他哲学家尝试继续拿筷子，这样的话吃饭的哲学家放下筷子之后，被阻塞的就可用获得。

### 管程
组成：共享数据结构、对数据结构初始化的语句、一组用来访问数据结构的过程
特征：各外部进程/线程只能通过管程提供的入口才能访问共享数据、每次仅允许一个进程在管程内执行某个内部过程。
## 死锁
### 死锁概念
每个进程都被因等待资源被阻塞，这就是死锁。
![[死锁、饥饿、死循环区别.png]]
#### 死锁产生条件
必须满足如下四个条件
1、互斥条件：只有对互斥使用的资源的争抢才会导致死锁
2、不剥夺条件：进程所获得的资源在未使用完之前，不能被其他进程剥夺走，只能主动释放。
3、请求和保持条件：进程已保持了至少一个资源，但又请求其他资源，其他资源被其他进程占用，因此请求进程被阻塞，但是对自己的资源又保持不放。
4、循环等待条件：存在一种进程资源的循环等待链。

有循环等待未必死锁，发生死锁一定循环等待。
#### 发生时机
1、对系统资源的竞争
2、进程推进顺序非法
3、信号量使用不当
#### 处理策略
1、预防死锁，破坏必要条件。
2、避免死锁，使用某种方法。
3、死锁检测和解除，允许发生死锁，系统检测并解除。
### 预防死锁
#### 破坏互斥条件
将资源设置缓冲区等方法，改造为可用共享使用的资源。
#### 破坏不剥夺条件
1、当进程请求新资源得不到满足时候，必须主动释放保持的所有资源，以后使用重新申请。
2、某个进程需要使用资源被其他进程占用时，可以由OS协助，将想用的资源强行剥夺。

实现负责；反复申请和释放增加系统开销；可能导致进程饥饿
#### 破坏请求和保持条件
静态分配方法：进程运行前，一次性申请完所需的所有资源，在资源为满足前，不投入运行。

资源利用率低；可能导致进程饥饿
#### 破坏循环等待条件
顺序分配法：给资源编号，规定各个进程必须==按编号递增的顺序请求资源==，同类资源一次性申请完。
一个进程只有已占有小编号资源时候，才有资格申请大编号，有大编号不可能逆向申请小编号，从而不会发生循环等待。

进程实际使用资源顺序和编号递增不一致，导致资源浪费。
### 避免死锁
安全序列：系统按照这种序列分配资源，则每个进程都能顺利完成。
如果处于安全状态，一定不死锁；如果不安全状态，可能发生死锁。
![[银行家算法1.png]]
![[银行家算法2.png]]
剩余资源：（3，3，2）
等找到一个可以完成的进程，将已用完的资源返回给剩余可用资源。
安全序列：{P1, P3, P0, P2, P4}
#### 银行家算法具体
![[银行家算法.png]]
### 死锁的检测和解除
#### 死锁检测
1、用某种数据结构来保存资源和分配信息
2、提供一种算法，利用上述信息来检测是否死锁
![[死锁检测.png]]
对于进程：进入边为分配边，出去边为请求边
#### 解除死锁
1、资源剥夺法：挂起某些死锁进程，并抢占它的资源。
2、==撤销进程法==：强制撤销某些或所有的死锁进程，并剥夺所有资源。
采用深度进程策略撤消：采用最短路径在森林中找一条代价最短的 路径，局部最优
采用宽度进程策略撤消：有N！种撤销序列的可能性，如全部遍历， 则全局最优

3、进程回退法：选择一个或多个进程回退到避免死锁的地步。
# 第三章 内存管理
## 内存管理
### 程序装入和链接
程序员编辑生成源文件；源文件编译生成目标模块（生成从0开始的逻辑地址）；目标模块链接成装入模块（生成从0开始的完整的逻辑地址）；装入模块装入内存（确定实际的物理地址）
#### 绝对装入
绝对装入：在编译之前，如果知道程序存放在内存中的哪个位置，编译程序产生绝对地址的目标代码。
只适用于单道程序环境。
![[绝对装入.png]]
#### 可重定位装入
 静态重定位：编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。
 在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。
 作业进入内存后，在运行期间就不能再移动了，也不能再申请内存空间。
 ![[静态重定位.png]] 
#### 动态重定位装入
 动态运行时装入：编译、链接后的装入模块都是从0开始的，装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把==地址转换推迟到程序真正要执行时才进行==。这种方式需要一个重定位寄存器支持。
 ![[动态重定位.png]]


#### 链接
##### 静态链接
程序运行前，将各个目标模块和他们所需的库函数链接成一个完整的可执行文件，之后不再拆开。
![[静态链接.png]]
##### 装入时动态链接
将各个目标模块装入内存时，边装入边链接。
![[装入时动态链接.png]]
##### 运行时动态链接
程序执行中需要某目标模块时，才对它进行链接，方便修改和更新，便于对目标模块共享。
![[运行时动态链接.png]]
### 内存管理
#### 内存空间分配和回收
#### 内存空间扩展
#### 地址转换
逻辑地址与物理地址转换
#### 内存保护
1、设置上下限寄存器，保存进程的上下限地址，判断进程指令访问的地址是否越界。
2、重定位寄存器和界地址寄存器，重定位寄存器记录进程起始物理地址，界地址寄存器存放进程的最大逻辑地址。
### 内存空间扩充：覆盖与交换
#### 覆盖技术
将程序分为多个段/多个模块，将常用段常驻内存，不常用段在需要时调入内存。
常驻内存段，放在固定区，调入后不再调出，除非运行结束。
不常用段，放在覆盖区，需要用到时调入内存，用不到时调出内存。
![[覆盖技术.png]]
必须由程序员声明覆盖技术，OS自动完成覆盖，对用户不透明增加了编程负担。
#### 交换技术
内存空间紧张时，系统将某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存。

暂时换出外存等待的进程状态为挂起态，挂起态又分为就绪挂起、阻塞挂起

1、进程被换出时，被放到磁盘的对换区，对换区采用连续分配方式，I/O速度更快。
2、当内存吃紧时候就进行对换，降低系统负担。
3、可优先换出阻塞进程；优先级低的进程；为了防止优先级低的进程饥饿，有的系统会考虑进程在内存中驻留时间。
==PCB常驻内存==
### 内存空间的分配与回收：连续分配管理方式
#### 单一连续分配
内存被分为系统区和用户区。
内存中只能有==一道用户程序==，用户程序独占整个用户区空间。
实现简单；无外部碎片；不一定需要内存保护
无法实现并发，只能用于单用户、单任务的OS；有内部碎片，存储器利用率低
#### 固定分区分配
将用户区分为若干固定大小的分区，在每个分区只装入一道作业。
分区大小相等：缺乏灵活性，适用于一台计算机控制多个相同对象的场合。
分区大小不等：灵活，可满足不同大小的进程需求。

OS需要一个数据结构---分区说明表，来实现对各个分区的分配和回收；每个表项包括分区==大小、起始地址、状态==
#### 动态分区分配
这种分配方式不会预先划分内存分区，在进程装入内存时，根据进程大小动态地建立分区。

1、采用空闲分区表或空闲分区链来记录空闲分区。
2、当一个新作业装入内存，有很多分区可以选择时候，根据动态分区分配算法来进行选择分区。
3、分区分配和回收，需要修改空闲分区表或空闲分区链。
### 内存空间的分配与回收：动态分区分配算法
#### 首次适应算法（First Fit）
 算法：每次从低地址开始查找，找到第一个能满足大小的空闲分区
 ==实现：空闲分区以**地址**递增的次序排列，每次分配内存时查找空闲分区链/空闲分区表==
#### 最佳适应算法（Best Fit）
算法：动态分区分配是一种连续分配方式，为各个进程分配的空间必须是连续的一整片区域，因此为了保证有大进程到来的时候有连续的大片空间，可以尽可能多地留下大片空闲区，即优先使用更小的空闲区。
==实现：空闲分区按**容量**递增次序链接 ，每次分配内存时顺序查找空闲分区链/空闲分区表==
缺点：每次都选用最小的分区进行分配，会留下越来越多、很小的内存块，会产生很多外部碎片。
#### 最坏适应算法（Worst Fit）
算法：为了解决Best Fit的问题，每次分配优先使用最大的连续空闲分区，这样每次分配后的空闲分区不会太小，，方便使用。
==实现：空闲分区按**容量**递减次序链接 ，每次分配内存时顺序查找空闲分区链/空闲分区表==
缺点：每次选择最大分区分配，导致后续来了大进程会没有内存分区可用。
#### 邻近适应算法（Next Fit）
算法：解决First Fit缺点，因为First Fit每次从链头开始查找，可能会导致低地址部分出现很多小空闲分区，然而每次分配查找都要经过这些分区，因此增加了查找开销；如果每次都从上一次找的位置开始检索，就能解决问题。
==实现：空闲分区以**地址**递增的顺序排列（可排成循环链表）（不需要进行更改链表顺序）。每次分配内存时，从上次查找结束的位置开始查找空闲分区链/空闲分区表。==
缺点：低地址、高地址被用的概率相同，导致大分区可能被分为小分区，导致后面无大分区可用。
![[动态分区分配算法.png]]
### 内存空间的分配与回收：非连续分配管理方式
#### 基本分页存储管理
1、分页存储：将内存分为一个个大小相等的分区，每个分区就是一个”页框“，每个页框有一个编号，就是”页框号“，页框号==*从0开始*==。
2、将进程的逻辑地址空间分为与页框大小相等的一个个部分，每个部分称为一个”页/页面“，每个页面也有一个编号，即”页号“，页号页是从0开始。
3、访问一个逻辑地址如果没快表，则需要访问两次内存，第一次查找页表，第二次访问物理地址
##### 页表
为了知道进程的每个页面在内存中存放的位置，OS要为每个进程建立一张页表。
页表存放在PCB中
==一个进程对应一张页表；进程每个页面对应一个页表项；每个页表项由”页号“和”块号“组成；页表记录进程页面和实际存放的内存块直接的映射关系==

页表中记录的只是内存的块号，而非实际的地址，计算地址要将块号×每块内存的大小
> Eg：假设物理内存为4GB，页面为4KB，则每个页表项至少为多少字节？
> 答：内存块大小 = 页面大小 = 4KB = 2的12次B
> 	4GB的内存被划分为 4GB / 4KB = 2的20次个内存块
> 	内存块号范围是 0 ~ 2的20次 - 1
> 	内存块号至少用20bit来表示
> 	至少要用3B来表示块号（3 * 8 = 24bit）
> 	
> 	页号不需要占用存储空间，因为页表项在内存中连续存放，不需要存储页号
> 	![[页表项.png]]
> Eg：假设页表中的各页表项从内存地址为X的地方开始连续存放，如何找到页号为i的页表项？
> 答：i号页表项的存放地址 = X + 3 * i；
> 		==因此每个页表项占3B，存储整个页表需要3*（n + 1）B；==


##### 地址转换
特点：进程的各个页面是离散存放的，但是页面内是连续存放的。

访问逻辑地址A：
1、确定逻辑地址A对应在进程中的页号P；
2、找到P号页面在内存中的起始地址（查页表）；
3、确定逻辑地址A的“页内偏移量”W

==逻辑地址A对应的物理地址 = P号页面在内存中的起始地址 + 页内偏移量W==

>Eg：某系统中，页面大小是50B。某进程逻辑地址空间大小为200B，则逻辑地址110对应的页号、页内偏移量是多少？
>答：进程200B被分为0号-3号总共4个页面
>	逻辑地址110对应在2号页面中。
>	页内偏移量 = 110 - 100 = 10

==页号 = 逻辑地址 / 页面长度 （取整数）
页内偏移量 = 逻辑地址 % 页面长度（取余数）==
![[地址变换机构.png]]
##### 基本地址变换机构
系统会设置一个==页表寄存器（PTR）==，存放页表在内存中的起始地址F和页表长度M（页表项个数）。
进程未执行时，页表起始地址和页表长度放在进程控制块（PCB）中，进程被调度时，OS内核会把它们放到页表寄存器中。

![[逻辑地址到物理地址转换.png]]
>Eg：页面大小为1K字节，页号2对应的内存块号b = 8，将逻辑地址A = 2500转换为物理地址E。
>答：页号 P = [A / L] = 2500 / 1024 = 2；  页内偏移量W = A % L = 2500 % 1024 = 452
>	由题可知，页号2没有越界，存放的内存块号为8
>	物理地址E = b * L + W = 8 * 1024 + 425 = 8644

##### 具有快表的地址变换机构
快表：TLB，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本
进程切换时，快表将会清除；快表是一个硬件
![[快表地址转换.png]]==**注意：系统是支持快表慢表同时查找，还是挨个查找；如果同时查找，若快表不命中，直接进行查找慢表，不需要再从头来。**==
![[快慢表查询时间.png]]
TLB中只存放页表项的副本
##### 两级页表
单级页表存在问题：
>Eg：某计算机按字节寻址，支持32位逻辑地址，采用分页式存储管理，页面大小为4KB，页表项长度为4B。
>答：4KB = 2的12次B，页内地址用12位表示，页号用20位表示。
>用户进程最多有2的20次页。一个进程的页表最多有2的20次 = 1M = 1048576个页表项，所以一个页表最大需要 1M * 4B = 4MB，共需要4MB / 4KB = 1K = 1024个页框存储该页表。


==由于数量太大，占用页框太多。==
==没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定页面。==
所以将页表再次进行分组，使每个内存块正好可以放一个分组。

对于上面的例子，一个进程最多有1M个页表项，每个页框可以存放4K / 4 = 1K = 1024个页表项，将所有的页表项按页框分为1024个二级页表，每个二级页表存入一个页框。
然后给每个二级页表进行标号，将标号和页框号存为页目录表，即二级页表

| [31 : 22] | [21 : 12] | [11 : 0]   |
|:---------:| --------- | ---------- |
| 一级页号  | 二级页号  | 业内偏移量 |
>Eg：将逻辑地址（0000000000,0000000001,111111111111）转换为物理地址（用10进制表示）
>![[二级页表.png]]

==**采用多级页表时候，各级页表大小不能超过一个页面
两级页表的访存次数：3次（访问内存中的页目录表、访问内存中的二级页表、访问目标内存单元）**==
n级页表访存次数是n+1
#### 基本分段存储管理
进程的地址空间：按照程序逻辑关系划分为若干段，每段从0开始编址。
内存分配规则：以段为单位进行分配，每个段在内存中占用连续空间，但是各段之间不可以相邻。
![[分段存储管理.png]]

逻辑地址由段号、段内地址组成
==段号位数决定了每个进程最多可以分为多少段、段内地址位数决定了每个段的最大长度==

**段表**：用段表记录每个段的段长和基址。 基址为32位/63位，段长位数为段内地址的位数。
![[分段管理地址转换过程.png]]
分段访存数量：第一次--查内存中段表； 第二次--访问目标内存单元；共计两次
#### 段页式管理
##### 分页分段优缺点
![[分页分段优缺点.png]]
##### 段页式管理的逻辑地址结构
![[段页式示例.png]]

| [31:16] | [15:12] | [11:0] |
| ---- | ---- | ---- |
| 段号 | 页号 | 页内偏移量 |
段号位数，决定了每个进程最多分为几段
页号位数，决定了每个段最大有多少页
页内偏移量，决定了页面大小、内存块大小
“分段”对用户是可见的，程序员编程需要显式的给出段号、段内地址；段页式管理的地址结构是二维的。
##### 段表、页表
段表：段号、页表长度（有几个页表项）、页表存放块号（页表起始地址）。
每个段表项长度相等，段号隐含。
每个页面对于一个页表项，每个页表项由页号、页面存放的内存块号组成，页号隐含。
##### 地址转换
![[段页式地址转换.png]]
三次访存：第一次访问段表、第二次访问页表、第三次访存
## 虚拟内存
### 请求分页管理存储
程序执行过程中，当访问的信息不在内存，OS将所需信息从外存调入内存（页面置换）
若内存不够，OS将内存中暂时用不到的信息换到外存（请求调页）
#### 页表机制
| 内存块号 | 状态位 | 访问字段 | 修改位 | 外存地址 |
| ---- | ---- | ---- | ---- | ---- |
| a | 1 | 10 | 0 | y |
状态位：是否调入内存
访问字段：记录最近被访问几次，或者上次访问时间，供置换算法参考
修改位：页面调入内存后是否被修改
外存地址：页面在外存中存放位置
#### 缺页中断机构
在请求分页系统中，当访问的页面不在内存时候，便会产生一个缺页中断，然后由OS的缺页中断程序处理中断。
此时缺页的进程阻塞，放入阻塞队列，当调页完成之后再唤醒放入就绪队列。
当内存中有空闲块，为进程分配空闲块，并装入该块，修改页表
若没有空闲块，则由页面置换算法选择一个页面淘汰，==若该页面在内存期间被修改，则要将其写回外存；未被修改的页面不用写回外存。==

该中断属于内中断，属于故障，有可能被处理程序修复。
#### 地址变换机构
与基本分页存储管理不同：
1、请求调页（查到页表项时进行判断）
2、页面置换（需要调入页面，但是没空闲内存块）
3、修改请求页表中新增的表项
![[请求分页管理地址转换.png]]
==当某个页面被调出内存，对应的快表也应该被删除
具有快表机构的请求分页系统，访问逻辑地址时，若缺页的步骤：查快表（未命中）--查慢表（未调入内存）--调页（调入的页表项会直接加入快表）--查快表（命中）--访存==
#### 页面置换算法
##### 最佳置换算法（OPT）
算法：每次淘汰页面时选择==以后永不使用==，或==在最长时间内不再被访问的页面==
![[最佳置换算法.png]]
缺页中断：9次  置换：6次
若有可用空闲内存块，则不需要进行页面置换
该算法为理想化算法，无法**实现**
##### 先进先出置换算法（FIFO）
算法：淘汰最早进入内存的页面
![[先进先出置换算法.png]]
![[先进先出置换算法2.png]]
==Belady异常：为进程分配的物理块增多时，缺页数不增反减。==
##### 最近最久未使用置换算法（LRU）
算法：每次淘汰的页面是最近最久未使用的页面
实现方法：在页表项中，加入一个访问字段，记录上次访问以来所经历的时间t
![[最近最久未使用置换算法.png]]
性能好，实现困难，开销大
##### ==时钟置换算法（CLOCK）==
算法：设置一个访问位，记录该页面是否被访问过，再将内存中的页面通过指针链接成==循环队列==；当页面被访问时，访问位置1；当需要淘汰一个页面时，检查页面访问位，如果为0则该页换出，如果为1，将他置0，暂不换出，之后继续扫描下一个页面；若所有的页面都为1，开启第二轮扫描。
##### 改进型时钟置换算法
如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存；只有被修改过才需要写回外存。
因此，OS还应该考虑是否被修改过，在其他都相同时，优先淘汰没有被修改过的页面，避免I/O操作。
设置一个修改位；（访问位，修改位）
算法：将页面拍成循环页面
第一轮：从当前开始扫描到第一个（0，0）的帧用于替换，本轮扫描不修改；==最近没访问，没修改==
第二轮：第一轮扫描失败，重新扫描，查找到第一个（0，1）帧用于替换。本轮将扫描过的所有访问位置0；==最近没访问，修改过==
第三轮：第二轮扫描失败，重新扫描，查找到第一个（0，0）帧用于替换。本轮扫描不修改；==最近访问过，没修改==
第四轮：第三轮扫描失败，重新扫描，查找到第一个（0，1）帧用于替换。本轮将扫描过的所有访问位置0；==最近访问过，修改过==
#### 页面分配策略
##### 驻留集
请求分页存储管理中给进程分配的物理块集合，一般小于进程总大小。
![[驻留集.png]]
##### 置换策略
![[置换策略.png]]
##### 何时何处调入
![[调入页面时间.png]]
![[调入内存地点.png]]
##### 工作集
抖动：页面频繁调入调出内存
工作集：某段时间内，进程实际访问页面集合
![[工作集.png]]OS可根据工作集大小给进程分配若干内存块。
# 第四章 文件管理
## 文件结构
### 文件的逻辑结构
#### 无结构文件
文件内部数据就是一系列二进制流或字符流组成，又称为流式文件。如txt
#### 有结构文件
由一组相似的记录组成，又称为记录式文件。每条记录由若干个数据项组成。如数据库表文件。
一般来说，每个记录有一个数据项可作为关键字。根据各条记录的长度是否相等，又分为定长记录和可变长记录。
##### 顺序文件
文件的记录一个接一个的顺序排列（逻辑上），记录是可变长或定长的。
记录在物理上可用顺序存储或链式存储。

随机存取：知道文件起始位置，找到第i个文件的地址
串结构：记录之间顺序与关键字无关
顺序结构：记录之间顺序按关键字顺序排列
![[顺序文件.png]]
顺序存储中，对于可变长记录，需要显式地给出记录长度
![[可变长记录.png]]
==定长记录的顺序文件，在物理上采用顺序存储，可实现随机存取；若能保证记录的顺序结构，可实现快速查找==
##### 索引文件
建立索引表加快对文件检索速度。每条记录对应一个索引项。
![[索引文件.png]]
可用不同数据项建立多个索引表。
##### 索引顺序文件
索引顺序文件并不是为每个记录建立一个索引表项，而是一组记录对应一个索引表项。
![[索引顺序文件.png]]
==索引表本质是一个定长、串结构的顺序文件==

若文件很多，可用为顺序文件建立多级索引表。
### 文件目录
#### 文件控制块
FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。
FCB包括了文件的基本信息、存取控制信息、使用信息。
最重要的是文件名、文件存放的物理地址。
#### 目录结构
##### 单级目录结构
一个系统建立一个目录表，每个文件占用一个目录项。
但是不允许文件重名。
##### 两级目录结构
分为主文件目录和用户文件目录
运行不同用户的文件重名
##### 多级目录结构
不同目录下的文件可以重名
从根目录出发路径称为绝对路径
/a/b/c.jpg
找到这个文件需要3次读磁盘的I/O操作，每次从外存中读入目录表，找到存放位置然后进入下一层。
当连续访问同一个目录内的多个文件，很低效，所以设置一个当前目录。
./b/c.jpg
==树形目录结构不方便实现文件共享==
##### 无环图目录结构
在树形目录基础上，增加了一些指向同一个节点的有向边，使整个目录成为一个有向无环图。
==可以用不同文件名指向同一个文件
每个共享结点设置共享计数器，当计数器减为0，才删除节点==
#### 索引结点
简化FCB
当搜索文件时，只关心文件名，将FCB的文件名提取出，建立一个索引结点表
由文件名、索引结点指针构成。该指针指向除了文件名以外的文件描述信息。
### 文件的物理结构
#### 连续分配
每个文件在磁盘上占用一组连续的块。
FCB中记录了文件起始块号和长度。
==物理块号 = 起始块号 + 逻辑块号==（验证是否合法）
连续分配支持顺序访问和直接访问（随机访问）
![[连续分配.png]]
连续读取的文件在顺序读/写时速度最快，因为磁头移动是顺序移动。
缺点：物理上采用连续分配，不方便文件拓展；存储空间利用率低，产生很多磁盘碎片。
#### 链接分配
采用离散分配，为文件分配离散磁盘块，分为隐式链接和显式链接。
##### 隐式链接（默认）
FCB中记录了文件起始块号和结束块号。
![[隐式链接.png]]
用户访问逻辑块号i，需要将前面的文件一个个读入内存找到下一个物理块，因此读取很慢。
==读取i个逻辑块，需要i+1次I/O操作==
只支持顺序访问，不支持随机访问
指向下一个盘块的指针也要耗费少量存储。
##### 显式链接
FCB中记录了文件的起始块号
将用于链接文件各物理块的指针显式的存放在一张表中，即文件分配表FAT
FAT常驻内存
![[显式链接.png]]
==逻辑块号转换成物理块号的过程不需要读磁盘操作
支持随机访问也支持顺序访问==
缺点：文件分配表占用一定存储空间
#### 索引分配
系统为每个文件建立一张索引表，索引表中记录了文件各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块，文件数据存放的磁盘称为数据块。
FCB中需要记录索引块是几号磁盘块。
![[磁盘分配.png]]
==索引表是一个文件对应一张==

逻辑块号到物理块号转换：从目录项找到索引表存放位置，将索引表从外存读入内存，查找索引表即可知道i号逻辑块在外存中存放位置。
支持随机访问，文件拓展也容易实现；索引表需要占用一定空间。

一个文件过大，产生的索引表一个磁盘块装不下，解决方案如下。
##### 链接方案
将多个索引块链接存放起来，FCB中只需要存放第一个索引块号
![[链接方案.png]]
找到后面的索引块，需要将前面的索引块挨个读取，因此效率很低。
##### 多层索引
类似于多级页表，使第一层索引块指向第二次索引块。
![[多层索引.png]]
各层索引表大小不能超过一个磁盘块。
基本上需要3次I/O，一级索引表，二级索引表，目标数据库
==采用K层索引结构，且顶级索引表为调入内存，访问一个数据块只需要K+1次读磁盘==
##### 混合索引
一个文件的顶级索引表中包含了一些直接地址索引，又包含了一级间接索引，还包含二级间接索引。
![[混合索引.png]]
### 文件的存储空间管理
#### 空闲表法
![[空闲表法.png]]
空闲块的起始块号，连续空闲块个数
用于连续分配方式
分配：同样可采用首次适应、最佳适应、最坏适应等算法来决定为文件分配哪个区间
回收：==回收磁盘块要注意表项合并==
#### 空闲链表法
空闲盘块链
![[空闲盘块链.png]]
系统保存==链头、链尾指针==
申请：若申请K个盘块，则从链头开始依次摘下K个盘块，并修改空闲链链头指针。
回收：将回收的盘块依次挂到链尾，并修改空闲链的链尾指针。
空闲盘区链
![[空闲盘区链.png]]
每个空闲盘区的第一个盘块记录了盘区长度、下一个盘区指针
系统保存==链头、链尾指针==
申请：采用首次适应、最佳适应、最坏适应等算法来决定分配哪个，若没有一个匹配的，可以将多个盘区分给同一个文件。
回收：回收区与某个空闲区相邻，则合并；若不相邻，则当作一个空闲盘区放到链尾
#### 位示图法
![[位示图法.png]]
一般该信息以“字”存储。
本例中，盘块号、字号、位号从0开始，若n表示字长，则
（字号，位号）=（i，j）的二进制位对应的盘块号 b = ni + j
b盘块对应的字号 i = b / n，位号 j = b % n；
分配：需要K个块，顺序扫描找到K个相邻或不相邻的“0”；根据字号位号计算出对应盘块进行分配；修改相应位为“1”
回收：根据回收盘块号计算对应字号、位号；修改相应位为“0”
==连续分配、离散分配都可以==

#### 成组链接法
文件卷的目录区中有一块磁盘作为“超级块”，系统启动时将其读入内存，并保持内存外存数据一致。
![[成组链接法.png]]==-1代表下一组已经没有空闲盘块==
回收：当正常回收就插入一个块，修改超级块
特殊回收：
![[成组链接法回收.png]]
### 文件共享
#### 基于索引结点的共享方式（硬链接）

![[索引结点.png]]
某用户删除文件，只会把count-1，当count = 0时，OS删除文件
#### 基于符号链的共享文件（软链接）
![[符号链的共享方式.png]]
当索引结点1被删除，count = 0；索引结点2将会失效。
### 文件保护（空）

## 文件系统的全局结构（空）

# 第五章 设备管理
## I/O系统
### I/O控制器
#### 功能
1、接受识别CPU命令（内有控制寄存器）
2、向CPU报告设备状态（内有状态寄存器）
3、数据交换（内有数据寄存器）
4、地址识别（判断CPU想操作哪个寄存器）
#### 组成
![[IO控制器组成.png]]
### I/O控制方式
#### 程序直接控制方式
![[程序直接控制.png]]
![[程序直接控制方式流程图.png]]
CPU在等待I/O完成的过程中和开始前需要不断==轮询检查==
缺点：长期忙等

#### 中断驱动方式
![[中断驱动方式IO.png]]
引入中断机构，先将I/O进程阻塞，当I/O结束之后再恢复进程。
数据传输单位：字
缺点：每次传送一个字，当数据量大时，频繁处理中断会消耗大量CPU时间。
#### DMA方式
直接存储器存取
数据不再经过CPU，直接进入存储器。
数据单位是块
![[DMA方式.png]]
DMA控制器：
![[DMA控制器.png]]
本质上也是一个字的读取，将其写入DR，然后再写入内存，连续的读取块，所以数据单位是块。
缺点：CPU每次发出一个I/O指令，只能读写一个或多个连续的数据块。
#### 通道控制方式
![[通道控制程序.png]]
通道可以指向的指令单一，可以识别并执行一系列通道指令
每次读写一组数据
CPU干预频率极低，只有完成一组数据块的读写后才发出中断信号，请求CPU干预

![[四种IO控制比较.png]]
### I/O软件层次结构
### I/O应用程序接口和驱动程序接口


## I/O核心子系统
### I/O调度
类似磁盘调度（先来先服务、最短寻道优先、SCAN、C-SCAN、LOOK、C-LOOK）
### 设备保护
设备是特殊的文件
根据FCB判断用户是否有权限访问

### 假脱机技术（SPOOLing）
脱机是指脱离主机的控制进行输入/输出操作。
![[SPOOLing技术.png]]
共享打印机：
![[共享打印机.png]]
### 设备分配和回收
#### 设备分配
##### 设备固有属性
独占设备：一个时段只能分配给一个进程。
共享设备：可同时分配给多个进程使用，如磁盘，各个进程宏观上同时使用，微观上交替使用。
虚拟设备：采用SPOOLing技术将独占设备改造为虚拟的共享设备。
##### 设备分配算法
先来先服务
短任务优先
优先级高者优先
##### 设备分配的安全性
1、安全性分配：为进程分配一个设备后就将设备阻塞，本次I/O完成后才将进程唤醒。
优点：破坏了请求和保持条件，不会死锁
缺点：对于一个进程来说CPU和I/O只能串行。
2、不安全分配方式：进程发出I/O请求后，OS分配I/O设备后，进程继续执行，还能发出新的I/O请求，只有某个I/O请求得不到满足才将进程阻塞。
优点：计算任务和I/O任务并行处理
缺点：有可能死锁（死锁避免、死锁检测和解除）
#### 分配方式
##### 静态分配
运行前就分配所有资源，运行结束后归还资源
破坏了请求和保持，不会死锁
##### 动态分配
进程运行中动态申请资源
#### 设备分配管理中的数据结构
设备控制表：DCT，系统为每个设备配置一张DCT，用于记录设备情况。
![[设备控制表.png]]

控制器控制表：COCT，每个设备控制器对应一张COCT
![[控制器控制表.png]]通道控制表：CHCT，每个通道对应一个CHCT
![[通道控制表.png]]
系统设备表：SDT，记录了系统中全部设备情况
![[系统设备表.png]]
#### 设备分配步骤
1、根据进程请求物理设备名查找SDT
2、根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列，若不忙碌将设备分配给进程
3、根据DCT找到COCT，若控制器忙碌将进程PCB挂到控制器等待队列，若不忙碌将控制器分配给进程。
4、根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列，若不忙碌将通道分配给进程。

若设备A忙碌，用户申请A，就算有同类型B设备空闲，也无法使用
改进：根据逻辑设备名（设备类型）查找SDT。
设置一个LUT（逻辑设备表）
### 缓冲区管理
#### 作用
1、缓和CPU和I/O设备速度不匹配的矛盾
2、减少CPU中断频率，放宽CPU中断相应时间的限制
3、解决数据粒度不匹配的问题
4、提高CPU和I/O设备的并行性
#### 单缓冲
OS在主存中为其分配一个缓冲区（无特殊说明，一个缓冲区就是一个块）
==缓冲区数据非空，不能往缓冲区写入数据，只能从缓冲区把数据传出；当缓冲区为空，可以传入数据，必须充满后才能把数据传出==
![[单缓冲区示例.png]]
#### 双缓冲
![[双缓冲区示例1.png]]
![[双缓冲区示例2.png]]
结论：采用双缓冲策略，处理一块数据平均耗时Max(T, C+M)；
#### 循环缓冲区
多个大小相等的缓冲区链接成一个循环队列
![[循环缓冲区.png]]
#### 缓冲池
![[缓冲池.png]]
### 磁盘
#### 磁盘调度算法
##### 一次磁盘读写时间
寻道时间T1：在读写数据前，将磁头移动到指定磁道花费时间。
1、启动磁头臂：s秒。
2、移动磁头：匀速移动，每次跨越一个磁道耗时m，总计n条磁道
T1 = s + m * n；

延迟时间T2：旋转磁盘，使磁头定位到目标扇区所需时间。
磁盘转速r
T2 = (1/2) * (1/r) = 1/2r

传输时间T3：从磁盘读出或写入磁盘经历的时间
磁盘转速r，此次读写数据字节数b，每个磁道上字节数N
T3 = (1/r) * (b/N) = b/(rN)

总平均时间：T = T1 + T2 + T3
##### 先来先服务算法（FCFS）
根据请求访问磁盘的先后顺序进行移动磁道
公平；如果磁道集中，算法性能还行
如果大量进程竞争磁道，磁道分散，性能差
##### 最短寻找时间优先（SSTF）
优先处理的磁道是离当前磁头最近的磁道
有可能产生饥饿
##### 扫描算法（SCAN）
只有磁头移动到最外侧磁道时候才能往里移动，移动到最内侧才能往外移动
不会饥饿
若连续来访问同一个磁道很多次的进程，就会导致访问非常慢
##### LOOK调度算法
在SCAN基础上，磁头移动方向上没有别的请求了，立即改变磁头方向
##### 循环扫描算法（C-SCAN）
只有磁头朝某个特定方向才处理磁道访问请求，返回时直接快速移动至起始端，不处理任何请求。
##### C-LOOK调度算法
在C-SCAN
基础上，如果返回磁头，将此头返回到有磁道访问请求的位置即可。
